import { format, isAfter, isBefore, isEqual, parseISO } from 'date-fns';
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
var YEAR_REGEXP_STRING = '(19[0-9]{2}|20[0-9]{2})';
var MONTH_REGEXP_STRING = '(0?[1-9]|1[0-2])';
var DAY_REGEXP_STRING = '(0?[1-9]|[12][0-9]|3[01])';
/**
 * Check if the value is empty
 *
 * @private
 * @param {*} value
 * @returns {boolean}
 * @memberof NumberValidator
 */
function isEmptyInputValue(value) {
    // we don't check for string here so it also works with arrays
    return value == null || value.length === 0;
}
/**
 * Custom validators related to numbers
 *
 * @export
 * @class NumberValidator
 */
var NumberValidator = /** @class */ (function () {
    function NumberValidator() {
    }
    /**
     *number validator
     *
     * @static
     * @param {FormControl} control
     * @returns {*}
     * @memberof NumberValidator
     */
    NumberValidator.number = function (control) {
        if (isEmptyInputValue(control.value)) {
            return null;
        }
        var value = (control.value || '') + '';
        var rege = /^[+-]?\d+$/;
        var valid = rege.test(value);
        return valid ? null : { requiredNumber: true };
    };
    /**
     * telephone number validator
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.telephone = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var rege = /^([0-9]{10,11}|[0-9]{2,4}-[0-9]{2,4}-[0-9]{4})$/;
        return rege.test(fc.value) ? null : { telephone: true };
    };
    /**
     * Date format validator
     * Only supports 1900 to 2099
     * Does not have validation for leap year or dates which does not exist (like april 31st)
     * @static
     * @param {string} [delimiter='']
     * @returns {ValidatorFn}
     * @memberof NumberValidator
     */
    NumberValidator.date = function (delimiter) {
        var _this = this;
        if (delimiter === void 0) { delimiter = ''; }
        return function (control) {
            return _this.validatorDateFormat(control.value, delimiter);
        };
    };
    /**
     * Validate the currentDate format by delimiters
     * @param separator
     */
    /* export function validatorCurrentDateFormat(currentDate: string): any {
  
    let value = (currentDate || '') + '';
    if (value === '') {
        return null;
    }
    value = value.split('-').join('/');
    const rege = /^[1-9]\d{3}\/(0[1-9]|1[0-2])\/(0[1-9]|[1-2][0-9]|3[0-1])$/;
    const valid = rege.test(value);
  
    return valid ? null : { dateFormat: true };
    }*/
    /**
     * Validate the currentDate format by delimiters
     *
     * @static
     * @param {string} currentDate
     * @returns {*}
     * @memberof StringValidator
     */
    NumberValidator.validatorDateFormat = function (currentDate, delimiter) {
        if (isEmptyInputValue(currentDate)) {
            return null;
        }
        var escapedDelimiter = delimiter.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&');
        var dateRegexString = '^' +
            YEAR_REGEXP_STRING +
            escapedDelimiter +
            MONTH_REGEXP_STRING +
            escapedDelimiter +
            DAY_REGEXP_STRING +
            '$';
        var regex = RegExp(dateRegexString);
        return regex.test(currentDate) ? null : { date: true };
    };
    /**
     * Year format validator
     * Only supports 1900 to 2099
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.year = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var regexString = '^' + YEAR_REGEXP_STRING + '$';
        return RegExp(regexString).test(fc.value) ? null : { year: true };
    };
    /**
     * Month format validator
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.month = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var regexString = '^' + MONTH_REGEXP_STRING + '$';
        return RegExp(regexString).test(fc.value) ? null : { month: true };
    };
    /**
     * Day format validator
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.day = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var regexString = '^' + DAY_REGEXP_STRING + '$';
        return RegExp(regexString).test(fc.value) ? null : { day: true };
    };
    /**
     * Postalcode format validator
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.postalcode = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var rege = /^([0-9]{3}-[0-9]{4}|[0-9]{7})$/;
        return rege.test(fc.value) ? null : { postalcode: true };
    };
    /**
     * halfwidth format validator including - and .
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.halfwidth = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var rege = /^[-]?[0-9]+(\.[0-9]+)?$/;
        return rege.test(fc.value) ? null : { halfwidth: true };
    };
    /**
     * fullwidth format validator including - and .
     *
     * @static
     * @param {FormControl} fc
     * @returns
     * @memberof NumberValidator
     */
    NumberValidator.fullwidth = function (fc) {
        if (isEmptyInputValue(fc.value)) {
            return null;
        }
        var rege = /^[ー]?[０-９]+(\．[０-９]+)?$/;
        return rege.test(fc.value) ? null : { fullwidth: true };
    };
    /**
     * 半角数字の金額
     *
     * @static
     * @param {FormControl} control
     * @returns {*}
     * @memberof StringValidator
     */
    NumberValidator.money = function (control) {
        var value = (control.value || '') + '';
        var rege = /^([1-9][0-9]*|0)?$/;
        var valid = rege.test(value);
        return valid ? null : { requiredNumber: true };
    };
    // パーセント数字(少数部2桁まで)
    /* export function validatorPercentNumbers(control: FormControl): any {
    const value = (control.value || '') + '';
    const rege = /^(^$|[1-9][0-9]{0,}|0)(\.[0-9]{1,2})?$/;
    const valid = rege.test(value);
    return valid ? null : { percentNumber: true };
  }*/
    /**
     * パーセント数字(少数部2桁まで)
     *
     * @static
     * @param {FormControl} control
     * @returns {*}
     * @memberof StringValidator
     */
    NumberValidator.percent = function (control) {
        if (isEmptyInputValue(control.value)) {
            return null;
        }
        var rege = /(^100(\.0{1,2})?$)|(^([1-9]([0-9])?|0)(\.[0-9]{1,2})?$)/;
        var valid = rege.test(control.value);
        return valid ? null : { percentNumber: true };
    };
    /**
     * 小数点以上と以下の桁数を指定する。
     * ※符号は桁数としてカウントする。（-12は3桁）
     *
     * @static
     * @param {number} integerLength
     * @param {number} decimalLength
     * @returns {*}
     * @memberof StringValidator
     */
    NumberValidator.decimal = function (integerLength, decimalLength) {
        return function (control) {
            var value = (control.value || '') + '';
            var rege = /^[+-]?(0|([1-9]\d*))(\.\d+)?$/g;
            var valid = value.split('.');
            if (value.length > 0 && !rege.test(value)) {
                return { decimalNumberFormat: true };
            }
            else if (valid && valid[0].length > integerLength) {
                return { integerNumber: { integerLength: integerLength } };
            }
            else if (valid && valid.length > 1 && valid[1].length > decimalLength) {
                return { decimalNumber: { decimalLength: decimalLength } };
            }
            return null;
        };
    };
    /**
     * Check the number can be full divied by specified radix.
     *
     * @static
     * @param {number} radix
     * @returns {ValidatorFn}
     * @memberof StringValidator
     */
    NumberValidator.radix = function (radix) {
        return function (control) {
            var value = +control.value;
            return value % radix === 0 ? null : { radixBase: { radix: radix } };
        };
    };
    // 過去日チェック
    /*
  export function validatorStartDate(currentDateStr: string): any {
    return (control: AbstractControl): { [key: string]: any } => {
        const value = (control.value || '') + '';
        if (value === '') {
            return null;
        }
        const dateFormatError = validatorCurrentDateFormat(currentDateStr);
        if (dateFormatError) {
            return dateFormatError;
        }
        // Get startDate from String represtation
        const startDate = new Date(value);
        const now = new Date(currentDateStr);
        const result = { startDateExceededNow: true };
  
        if (startDate.getFullYear() > now.getFullYear()) {
            return result;
        } else if (startDate.getFullYear() === now.getFullYear()
            && startDate.getMonth() > now.getMonth()) {
            return result;
        } else if (startDate.getFullYear() === now.getFullYear()
            && startDate.getMonth() === now.getMonth()) {
                if (startDate.getDate() && startDate.getDate() > now.getDate()) {
                    return result;
                }
        }
        return null;
    };
  }
  */
    // 生年月日チェック
    /*
  export function validatorBirthDate(separator: string): any {
    return (control: AbstractControl): { [key: string]: any } => {
        const value = (control.value || '') + '';
        if (value === '') {
            return null;
        }
        const dateFormatError = validatorDateFormat(separator);
        if (dateFormatError) {
            return dateFormatError;
        }
        // Get BirthDay from String represtation
        const brithDate = new Date(value);
        const now = new Date();
        const result = { birthDateExceededNow: true };
        if (brithDate.getFullYear() > now.getFullYear()) {
            return result;
        } else if (brithDate.getFullYear() === now.getFullYear()
            && brithDate.getMonth() > now.getMonth()) {
            return result;
        } else if (brithDate.getFullYear() === now.getFullYear()
            && brithDate.getMonth() === now.getMonth()
            && brithDate.getDate() > now.getDate()) {
            return result;
        }
        return null;
    };
  }*/
    /**
     * Check if the date is before the baseDate
     * baseDate format is expected to be yyyy-MM-dd format with specified separator that is set in the first parameter
     *
     * @static
     * @param {string} separator
     * @param {string} [baseDate=''] if baseDate is not filled, use system date
     * @returns {*}
     * @memberof NumberValidator
     */
    NumberValidator.pastDate = function (separator, baseDate) {
        var _this = this;
        if (baseDate === void 0) { baseDate = ''; }
        return function (control) {
            return _this.compareDates(control.value, true, separator, baseDate);
        };
    };
    /**
     * Check if the date is after the baseDate
     * baseDate format is expected to be yyyy-MM-dd format with specified separator that is set in the first parameter
     *
     * @static
     * @param {string} separator
     * @param {string} [baseDate=''] if baseDate is not filled, use system date
     * @returns {*}
     * @memberof NumberValidator
     */
    NumberValidator.futureDate = function (separator, baseDate) {
        var _this = this;
        if (baseDate === void 0) { baseDate = ''; }
        return function (control) {
            return _this.compareDates(control.value, false, separator, baseDate);
        };
    };
    /**
     * Compare 2 dates.
     * If past is ture, check if value is before the baseDate
     * If past is false, check if value is after the baseDate
     *
     * @private
     * @param {string} value
     * @param {boolean} past
     * @param {string} separator
     * @param {string} baseDate
     * @returns {{ [key: string]: any }}
     * @memberof NumberValidator
     */
    NumberValidator.compareDates = function (value, past, separator, baseDate) {
        if (isEmptyInputValue(value)) {
            return null;
        }
        var dateFormatError = NumberValidator.validatorDateFormat(value, separator);
        if (dateFormatError) {
            return dateFormatError;
        }
        var comparedDate = value.split(separator).join('-');
        if (baseDate.length > 0) {
            baseDate = baseDate.split(separator).join('-');
        }
        else {
            baseDate = format(new Date(), 'yyyy-MM-dd');
        }
        var baseDateObject = parseISO(baseDate);
        var comparedDateObject = parseISO(comparedDate);
        if (past) {
            if (isBefore(baseDateObject, comparedDateObject) ||
                isEqual(baseDateObject, comparedDateObject)) {
                return { pastDate: true };
            }
        }
        else {
            if (isAfter(baseDateObject, comparedDateObject) ||
                isEqual(baseDateObject, comparedDateObject)) {
                return { futureDate: true };
            }
        }
        return null;
    };
    NumberValidator.ɵfac = function NumberValidator_Factory(t) { return new (t || NumberValidator)(); };
    NumberValidator.ɵprov = i0.ɵɵdefineInjectable({ token: NumberValidator, factory: NumberValidator.ɵfac });
    return NumberValidator;
}());
export { NumberValidator };
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NumberValidator, [{
        type: Injectable
    }], null, null); })();
//# sourceMappingURL=number.validator.js.map