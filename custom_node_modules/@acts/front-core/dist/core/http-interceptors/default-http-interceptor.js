import { Observable, throwError } from 'rxjs';
import { catchError, tap, timeout } from 'rxjs/operators';
import { HttpResponse } from '@angular/common/http';
import { Inject, Injectable, InjectionToken } from '@angular/core';
import { AuthQuery } from '../auth/auth.query';
import { ApiSystemError, ApiValidationError, AuthenticationError, MaintenanceError, NetworkError } from '../error-handler/errors';
import { ObjectUtils } from '../utils/object.utils';
import * as i0 from "@angular/core";
import * as i1 from "../auth/auth.query";
export var DEFAULT_HTTP_TIMEOUT = new InjectionToken('defaultTimeout');
/**
 * angular httpclient header inspect class
 *
 * @export
 * @class AuthInterceptor
 * @implements {HttpInterceptor}
 */
var DefaultHttpInterceptor = /** @class */ (function () {
    /**
     * Creates an instance of DefaultHttpInterceptor.
     * @param {number} defaultTimeout
     * @param {Injector} injector
     * @memberof DefaultHttpInterceptor
     */
    function DefaultHttpInterceptor(defaultTimeout, auth) {
        this.defaultTimeout = defaultTimeout;
        this.auth = auth;
        // tslint:disable-next-line: typedef
        // 秒落ちに対して対応。mm:ssともに省略になる場合に関してはDate型に変更できない為、iso8601regexに含んでいない。
        this.iso8601regex = /(^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$)|(^\d{4}-\d\d-\d\dT\d\d:\d\d?(([+-]\d\d:\d\d)|Z)?$)|(^\d{4}-\d\d-\d\d?$)/;
    }
    /**
     * Intercept angular http connection
     *
     * @param {HttpRequest<any>} req
     * @param {HttpHandler} next
     * @returns {Observable<HttpEvent<any>>}
     * @memberof DefaultHttpInterceptor
     */
    DefaultHttpInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        // to call APIs hosted on localhost from Android emulator
        // TODO: still need to consider calling API from real devices
        var targetUrl = req.url;
        // get timeout value
        var timeoutValue = Number(req.headers.get('timeout')) || this.defaultTimeout;
        // Get the auth token from the service.
        var authToken = this.auth.getAuthorizationToken();
        // Clone the request and replace the original headers with
        // cloned headers, updated with the authorization.
        var defReq = req.clone({
            url: targetUrl,
            headers: req.headers.set('Authorization', "" + authToken)
        });
        // send cloned request with header to the next handler.
        return next.handle(defReq).pipe(tap(function (event) {
            if (event instanceof HttpResponse) {
                var body = event.body;
                _this.convertToDate(body);
            }
        }), timeout(timeoutValue), catchError(function (error) { return _this.switchError(error); }));
    };
    /**
     * Convert body string to date
     *
     * @protected
     * @param {*} body
     * @returns {void}
     * @memberof DefaultHttpInterceptor
     */
    DefaultHttpInterceptor.prototype.convertToDate = function (body) {
        if (body === null || body === undefined) {
            return body;
        }
        if (typeof body !== 'object') {
            return body;
        }
        for (var _i = 0, _a = Object.keys(body); _i < _a.length; _i++) {
            var key = _a[_i];
            var value = body[key];
            if (this.isIso8601(value)) {
                body[key] = new Date(value);
            }
            else if (typeof value === 'object') {
                this.convertToDate(value);
            }
        }
    };
    /**
     * is ISO8601 String
     *
     * @protected
     * @param {*} value
     * @returns {boolean}
     * @memberof DefaultHttpInterceptor
     */
    DefaultHttpInterceptor.prototype.isIso8601 = function (value) {
        if (value === null || value === undefined) {
            return false;
        }
        return this.iso8601regex.test(value);
    };
    /**
     * switch errors
     *
     * @protected
     * @param {HttpErrorResponse} error
     * @returns {Observable<never>}
     * @memberof DefaultHttpInterceptor
     */
    DefaultHttpInterceptor.prototype.switchError = function (error) {
        var _this = this;
        if (error.error instanceof Blob &&
            error.error.type === 'application/json') {
            // handle error response for blob
            // from angular issue
            // https://github.com/angular/angular/issues/19888#issuecomment-522119151
            return new Observable(function (observer) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        var newError = ObjectUtils.clone(error);
                        var errorMessage = JSON.parse(e.target.result);
                        newError.error = errorMessage;
                        observer.error(_this.createApplicationError(newError));
                    }
                    catch (observerError) {
                        observer.error(observerError);
                    }
                };
                reader.onerror = function () {
                    observer.error(_this.createApplicationError(error));
                };
                reader.readAsText(error.error);
            });
        }
        return throwError(this.createApplicationError(error));
    };
    /**
     * create ApplicationError from error response status code
     *
     * @private
     * @param {HttpErrorResponse} error
     * @returns {ApplicationError}
     * @memberof DefaultHttpInterceptor
     */
    DefaultHttpInterceptor.prototype.createApplicationError = function (error) {
        switch (error.status) {
            case 400:
                return new ApiValidationError(error);
            case 401:
                return new AuthenticationError(error);
            case 500:
                return new ApiSystemError(error);
            case 503:
                return new MaintenanceError(error);
            default:
                return new NetworkError(error);
        }
    };
    DefaultHttpInterceptor.ɵfac = function DefaultHttpInterceptor_Factory(t) { return new (t || DefaultHttpInterceptor)(i0.ɵɵinject(DEFAULT_HTTP_TIMEOUT), i0.ɵɵinject(i1.AuthQuery)); };
    DefaultHttpInterceptor.ɵprov = i0.ɵɵdefineInjectable({ token: DefaultHttpInterceptor, factory: DefaultHttpInterceptor.ɵfac });
    return DefaultHttpInterceptor;
}());
export { DefaultHttpInterceptor };
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DefaultHttpInterceptor, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DEFAULT_HTTP_TIMEOUT]
            }] }, { type: i1.AuthQuery }]; }, null); })();
//# sourceMappingURL=default-http-interceptor.js.map